#### 类的生命周期

------

###### 加载（Loading）->验证（Verification）->准备（Preparation）->解析（Resolution）->初始化（Initialization）->使用（Using）->卸载（Unloading）

其中：

1.  验证、准备、解析三个部分统称为连接（Linking）

2. 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。

##### 有且只有的必须立即对类进行“初始化”（加载、验证、准备自然需要在此之前开始）的五种情况：

1. 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时。生成这4条指令的最常见的Java代码场景是：使用**new关键字实例化对象**的时候、**读取或设置一个类的静态字段**（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及**调用一个类的静态方法**的时候。
2. 使用java.lang.reflect包的方法对类进行**反射调用**时。
3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要**先触发其父类的初始化**。
4. 当虚拟机启动时，用户需要指定一个要执行的主类（**包含main()方法的那个类**），虚拟机会先初始化这个主类。
5. 当使用JDK1.7 的**动态语言支持**时，如果一个java.lang.invoke.MethodHandle 实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

注：这五种场景中的行为称为对一个类进行**主动引用**，除此之外，其它所有引用类的方式都不会触发初始化，称为**被动引用**。

#### 双亲委派模型

------

###### 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。通俗点说：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义。

![在这里插入图片描述](https://raw.githubusercontent.com/chuerat/MarkDownImages/master/ParentsDelegationModel.png)

上图中展示的类加载器之间的这种层次关系，称为**类加载器的双亲委派模型**。

1. 要求：除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系来实现，而都是使用组合关系来复用父加载器的代码。
2. 工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。
3. Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object,它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处在模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。

