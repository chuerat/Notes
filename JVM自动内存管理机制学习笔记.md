#### JVM对Java运行时数据区的划分

------

1. ###### 程序计数器（线程私有）

   可以看作是当前线程所执行的字节码的行号指示器。

2. ###### Java虚拟机栈（线程私有）

   描述Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数帧、动态链接、方法出口等信息。

3. ###### 本地方法栈（线程私有）

   与虚拟机栈作用类似，为虚拟机使用到的Native方法服务。

4. ###### Java堆（线程共享）

   存放对象实例，是垃圾收集器（GC）管理的主要区域，也称GC堆。

5. ###### 方法区（线程共享）

   - 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
   - **运行时常量池**是方法区的一部分，主要用于存放编译期产生的各种字面量和符号引用（类加载后）。其具有动态性：除了预置入Class文件中常量池的内容，运行期间产生的新的常量也能入池（例如String类中的intern()方法）。

#### 判断对象是否存活

------

1. ###### 引用计数算法

   给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用的对象。**但是很难解决对象之间相互循环引用的问题。**

2. ###### 可达性分析算法（Java中采用）

   从GC Roots到这个对象不可达时，则证明此对象不可用。Java中，GC Roots的对象包括下面几种：

   - 虚拟机栈（栈帧中的本地变量表）中引用的对象。
   - 方法区中类静态属性引用的对象。
   - 方法区中常量引用的对象。
   - 本地方法栈中JNI（即一般说的Native方法）引用的对象。

#### 垃圾收集算法

------

1. ###### 标记-清除算法（CMS收集器采用）

   首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

   **缺点**：标记和清除两个过程的效率都不高； 标记清除后会产生大量不连续的内存碎片（可能导致以后需要分配较大对象时，因无法找到足够的连续内存而提前触发GC）。

2. ###### 复制算法（用于新生代（Young Generation，一般情况下，对象存活率极低）的回收）

   新生代中分为一块**Eden**空间和两块**Survivo**r空间（HotSpot虚拟机默认Eden大小：Survivor大小=8：1）。每次使用Eden和其中一块Survivor，回收时，将Eden和Survivor中还存活着的对象一次性地复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。当Survivor空间不够用时，依赖老年代进行分配担保。

3. ###### 标记-整理算法（用于老年代（Tenured Generation，对象存活率较高）的回收）

   首先标记出所有需要回收的对象，在标记完成后让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

#### 垃圾收集器

------

1. 在新生代中采用的：

   - **Serial收集器**：单线程的收集器。它只会使用一个CPU或一条收集线程去完成垃圾收集工作；它在进行垃圾收集时，必须暂停其它所有的工作线程，直到它收集结束（“Stop The World”）。

   - 优点：简单而高效（与其它收集器的单线程相比），适合运行在Client模式下的虚拟机。

   - **ParNew收集器**：Serial收集器的多线程版本，适合运行在Server模式下的虚拟机。
   - **Parallel Scavenge收集器**：目的是达到可控制的吞吐量。有GC自适应的调节策略：会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。另外它不能与CMS收集器配合工作。

   注：停顿时间短适合与用户交互的程序，良好的响应速度能提升用户体验；高吞吐量可以高效率地利用CPU时间，尽快完成程序地运算任务，主要适合在后台运算而不需要太多交互的任务。

2. 在老年代中采用的：

   - **Serial Old收集器**：Serial收集器的老年代版本。
   - **Parallel Old收集器**：Parallel Scavenge收集器的老年代版本，只配合Parallel Scavenge收集器使用，达到吞吐量优先的目的。
   - **CMS收集器**：基于“标记-清除”算法实现，是一种获取最短回收停顿时间为目标的收集器。
     - 优点：并发收集、低停顿。
     - 缺点：
       1. 对CPU资源非常敏感，并发执行必然导致吞吐量降低，应用程序变慢。
       2. 无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。
       3. “标记-清除”算法的缺点

3. **G1（Garbage-First）收集器**：它将Java堆划分为多个大小相等的区域（**Region**，虽然还保留新生代和老年代的概念，但两者不再是物理隔离的了，他们是一部分Region（不需要连续）的集合），同时跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。

#### Minor GC和Full GC的区别

------

- 新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具有朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。
- 老年代GC（Major GC/Full GC）：指发生在老年代的GC，也出现了Major GC，经常会伴随至少一次的Minor GC（也是称为Full GC的原因）。Major GC的速度一般会比Minor GC慢10倍以上。

#### 内存分配与回收策略（Serial/Serial Old收集器下）

------

1. ###### 对象优先在Eden分配（Eden区没有足够空间时，JVM将发起一次Minor GC）

2. ###### 大对象直接进入老年代（大对象是指需要大量连续内存空间的Java对象）

3. ###### 长期存活的对象将进入老年代

   JVM给每个对象定义了一个对象年龄（Age）计数器，如果对象在Eden出生并经过第一次Minor GC后被移动到Survivor空间中，那么对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。

4. ###### 动态对象年龄判定

   如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年区。

5. ###### 空间分配担保

   在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果是，那么Minor GC可以确保是安全的。

